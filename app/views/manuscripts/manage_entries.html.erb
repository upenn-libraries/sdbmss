<% content_for :head do %>
<%= stylesheet_link_tag "extras", media: "all" %>
<%= javascript_include_tag "extras" %>
<style>

.navbar { margin-bottom: 10px; }

#main-container.container-fluid .row { padding-left: 15px; padding-right: 15px; }

</style>
<script type="text/javascript">

$(document).ready(function() {

    var manuscriptId = parseInt($("#manuscript_id").val());

    // data structure containing entry <-> MS associations that user
    // manipulates through UI. This is initially populated out of the
    // database but can contain entries that user just wants to view.
    var entryManuscripts;

    var firstTableLoad = true;

    // returns an Object whose keys are all entry ids that should be
    // displayed in the table
    var getEntryIds = function() {
        return entryManuscripts.map(function (entry_manuscript) {
            return entry_manuscript.entry_id;
        }).reduce(function (prev, curr, idx, array) {
            prev[curr] = 1;
            return prev;
        }, {});
    };

    // TODO: hacks to tweak the Rails layout: figure out a more elegant way?
    $("#search-navbar").remove();
    // make this page take up full width of browser window
    $("#main-container").removeClass("container").addClass("container-fluid");

    var radioButtonsShouldBeVisible = function (sdbmTable, row) {
        return !row[sdbmTable.getColumnIndex("Manuscript")] || row[sdbmTable.getColumnIndex("Manuscript")] === manuscriptId;
    };

    var getRadioButtonHTML = function(sdbmTable, data, value) {
        if (radioButtonsShouldBeVisible(sdbmTable, data)) {
            return '<input type="radio" name="entry_id_' + data[sdbmTable.getColumnIndex("ID")] + '" value="' + value + '" />';
        }
        return '';
    };

    var sdbmTable = new SDBMEntryTable("#entries-for-manuscript", {
        order: [["Manuscript", "desc"]],
        prependColumns: [
            {
                title: 'Link',
                "data": null,
                "orderable": false,
                "className": 'text-center',
                "render": function (data, type, full, meta) {
                    return getRadioButtonHTML(sdbmTable, data, "is");
                }
            },
            {
                title: 'Fragment',
                "data": null,
                "orderable": false,
                "className": 'text-center',
                "render": function (data, type, full, meta) {
                    return getRadioButtonHTML(sdbmTable, data, "partial");
                }
            },
            {
                title: 'Possible',
                "data": null,
                "orderable": false,
                "className": 'text-center',
                "render": function (data, type, full, meta) {
                    return getRadioButtonHTML(sdbmTable, data, "possible");
                }
            },
            {
                title: 'Unlink',
                "data": null,
                "orderable": false,
                "className": 'text-center',
                "render": function (data, type, full, meta) {
                    return getRadioButtonHTML(sdbmTable, data, "unlink");
                }
            }
        ],
        ajax: function (sdbmTable, dt_params, callback, settings) {
            if(firstTableLoad) {
                $("#spinner").show();
                $.ajax({
                    url: '/manuscripts/' + manuscriptId + '.json',
                    type: 'GET',
                    success: function(data, textStatus, jqXHR) {
                        entryManuscripts = data.entry_manuscripts;
                        console.log(entryManuscripts);
                        var params = sdbmTable.translateParamsToBlacklight(dt_params);
                        params['entry_id'] = Object.keys(getEntryIds()).join(" OR ");
                        sdbmTable.searchAndUpdateTable(params, callback);
                    },
                    error: function() {
                        // TODO: fill this out
                        alert("An error occurred jumping to this record.");
                    },
                    complete: function() {
                        $("#spinner").hide();
                    }
                });
                firstTableLoad = false;
            } else {
                var params = sdbmTable.translateParamsToBlacklight(dt_params);
                params['entry_id'] = Object.keys(getEntryIds()).join(" OR ");
                sdbmTable.searchAndUpdateTable(params, callback);
            }
        }
    });

    // since table rows are re-created on reloads, we have to set the
    // state of the radio buttons after redraw
    $("#entries-for-manuscript").on('draw.dt', function () {
        $.each(entryManuscripts, function (idx, entryManuscript) {
            if(entryManuscript.relation_type) {
                $("input[name='entry_id_" + entryManuscript.entry_id + "'][value='" + entryManuscript.relation_type + "']").prop("checked", true);
            };
        });

        // highlight the original rows linked to the MS
        sdbmTable.dataTable.rows().nodes().each(function (row, idx, api) {
            var data = sdbmTable.dataTable.row(row).data();
            var colIdx = sdbmTable.getColumnIndex("Manuscript");
            if(data[colIdx] === "SDBM_MS_" + manuscriptId) {
                $(row).css("font-style", "italic");
            }
        });
    });

    // entryIds is an array of ids
    var addEntryIds = function(entryIds) {
        var existingEntryIds = getEntryIds();
        $.each(entryIds, function (idx, id) {
            if (!existingEntryIds[id]) {
                entryManuscripts.push({
                    entry_id: parseInt(id),
                    manuscript_id: manuscriptId
                });
            }
        });
        sdbmTable.reload();
    };

    var addEntryIdsFromInput = function () {
        addEntryIds($("#entry_ids").val().split(/[,\s]/));
    };

    $("#entry_ids").keydown(function(e) {
        if(e.keyCode == 13) {
            addEntryIdsFromInput();
            e.preventDefault();
            return false;
        }
    });

    $("#show").click(function () {
        addEntryIdsFromInput();
    });

    $("#show-matches").click(function () {
        $("#spinner").show();
        $.ajax({
            url: '/manuscripts/' + manuscriptId + '/entry_candidates.json',
            type: 'GET',
            success: function(data, textStatus, jqXHR) {
                entry_ids = data.entry_candidates;
                addEntryIds(entry_ids);
            },
            error: function() {
                // TODO: fill this out
                alert("An error occurred finding matches.");
            },
            complete: function() {
                $("#spinner").hide();
            }
        });
    });

    $("#save").click(function () {
        var entryManuscriptsFiltered = JSON.parse(JSON.stringify(entryManuscripts));

        entryManuscriptsFiltered = entryManuscriptsFiltered.filter(function (entryManuscript) {
            if(!entryManuscript.id && !entryManuscript.relation_type) {
                return false;
            }
            return true;
        });
        $.each(entryManuscriptsFiltered, function(idx, entryManuscript) {
            if(entryManuscript.id && entryManuscript.relation_type === 'unlink') {
                entryManuscript._destroy = '1';
            }
        });

        console.log(entryManuscriptsFiltered);

        $.ajax({
            contentType: 'application/json',
            url: '/entry_manuscripts/update_multiple.json',
            type: 'PUT',
            dataType: 'json',
            data: JSON.stringify({
                manuscript_id: manuscriptId,
                entry_manuscripts: entryManuscriptsFiltered
            }),
            success: function(data, textStatus, jqXHR) {
                alert("Your changes have been saved");
                location.reload(true);
            },
            error: function() {
                // TODO: fill this out
                alert("An error occurred saving associations.");
            }
        });

    });

    // when user selects a radio button, update our entryManuscripts data structure
    $(document).on("change", "input[type=radio]", function(event) {
        if($(event.target).is(":checked")) {
            var entryId = parseInt($(event.target).attr("name").replace("entry_id_", ""));
            $.each(entryManuscripts, function (idx, entryManuscript) {
                if(entryManuscript.entry_id === entryId) {
                    entryManuscript.relation_type = $(event.target).val();
                }
            });
        }
    });

 });

</script>
<% end %>

<% if @manuscript.persisted? %>
<input type="hidden" id="manuscript_id" value="<%= @manuscript.id %>" />
<% end %>

<h3>Manage entries linked to <%= @manuscript.public_id %></h3>

<div class="form-horizontal">
    <div class="row form-group">
        <label class="col-sm-2 text-right control-label">
            Show these entries in table:
        </label>
        <div class="col-sm-1">
            <input type="text" id="entry_ids" class="form-control"/>
        </div>
        <div class="col-sm-1">
            <button id="show" class="btn btn-primary">Show</button>
        </div>
        <div class="col-sm-3">
            <button id="show-matches" class="btn btn-primary">Show potential matches</button>
        </div>
        <div class="col-sm-1">
            <div>
                <img id="spinner" alt="working..." style="display: none;" src="<%= asset_path "spinner.gif" %>"/>
            </div>
        </div>
        <div class="col-sm-3"></div>
        <div class="col-sm-1">
            <button id="save" class="btn btn-primary">Save Changes</button>
        </div>
    </div>
</div>

<table id="entries-for-manuscript" class="sdbm-table table dataTable table-striped table-bordered nowrap compact" width="100%" cellspacing="0">
    <thead>
        <tr>
            <!-- we populate TH elements dynamically -->
            
            <!-- TODO: figure out how to get datatables to initialize
            with reasonable static widths; widget seems to
            automatically resize for data, which is not what we
            want. this might require dynamically resizing after init
            is finished? 
              -->
        </tr>
    </thead>
    <tbody>
    </tbody>
</table>

